<!doctype html>
<html>
    <head>
        <meta charset="utf-8"></meta>
        <meta http-equiv="X-UA-Compatible" content="chrome=1"></meta>
        <meta name="viewport" content="width=device-width"></meta>
        <!-- favicon from http://findicons.com/icon/445768/blue_lego?id=445922 -->
        <link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link>
        <title>Shake Build System</title>
        <link rel="stylesheet" href="index.css"></link>



    </head>
    <body class="page-faq">

<div id="header">
    <a href="https://shakebuild.com" id="header-root">Shake build system</a>
    <a href="." id="header-first">Home</a>
    <a href="why">Why Shake</a>
    <a href="manual">Manual</a>
    <a class="active" href="faq">FAQ</a>
</div>

<div id="content"><h1>FAQ</h1>
<span class="target" id="what-else-is-on-this-website"></span><h4><a href="#what-else-is-on-this-website" class="anchor">Q: What else is on this website?</a></h4>
<ul><li><a href="./manual">User manual</a> &ndash; the place to start, which also serves as a tutorial.</li>
<li><a href="./why">Why</a> &ndash; details on why you should use Shake, for those who are easily influenced.</li>
<li><a href="./includes">Includes</a> &ndash; how to deal with <code>#include</code> files, import statements and other dependencies between files.</li>
<li><a href="./debugging">Debugging</a> &ndash; how to determine what a Shake build system is doing.</li>
<li><a href="./profiling">Profiling and optimisation</a> &ndash; how to speed up an existing Shake build system.</li>
<li><a href="./commandline">Command line flags</a> &ndash; the flags and settings supported by Shake, a better version of <code>--help</code>.</li>
<li><a href="./developing">Developing Shake</a> &ndash; notes for people who want to contribute to Shake itself.</li>
<li><a href="./ninja">Ninja</a> &ndash; features of Shake for those people who use Ninja.</li>
</ul>
<!--
Shake is suitable for all sizes of build systems, from a simple C project to a huge cross-platform multi-language project. However, at different scales, different techniques tend to be applicable.<ul><li><a href="Small.md#readme">Small/simple build systems</a> -- some simpler build systems can be written as <i>forward</i> build systems, without the need to explicitly think about dependencies or targets. Useful for getting started, relies on a tool to automatically track your dependencies.</li><li><a href="Large.md#readme">Large frequently changing build systems</a> -- for large build systems, it is useful to split the build system interpreter and metadata apart, making changes to the Haskell build system comparatively rare.</li></ul><p>--&gt;</p><h4>Q: Any more documentation?</h4><p>There is a complete list of <a href="https://hackage.haskell.org/packages/archive/shake/latest/doc/html/Development-Shake.html">every function in Shake</a> which <a href="http://hoogle.haskell.org/?package=shake">can be searched</a>. Each function comes with documentation and examples.</p><p>Much of the theory behind Shake is covered in <a href="https://ndmitchell.com/downloads/paper-shake_before_building-10_sep_2012.pdf">a conference paper</a> which was accompanied by <a href="https://www.youtube.com/watch?v=xYCPpXVlqFM">this video</a> (<a href="https://ndmitchell.com/downloads/slides-shake_before_building-10_sep_2012.pdf">slides</a>). Since then I&#39;ve given videoed talks on <a href="https://www.infoq.com/presentations/shake">small worked examples</a> (<a href="https://ndmitchell.com/downloads/slides-building_stuff_with_shake-20_nov_2014.pdf">slides</a>) and <a href="https://skillsmatter.com/skillscasts/6548-defining-your-own-build-system-with-shake">how to structure large Shake systems</a> (<a href="https://ndmitchell.com/downloads/slides-defining_your_own_build_system_with_shake-09_oct_2015.pdf">slides</a>).</p><p>I sometimes write about ongoing development work or other Shake-related things on <a href="https://neilmitchell.blogspot.co.uk/search/label/shake">my blog</a>.</p><p>If you have any further questions:</p><ul><li><a href="https://stackoverflow.com/questions/tagged/shake-build-system">Ask on StackOverflow</a>, using the tag <code>shake-build-system</code>.</li><li><a href="https://groups.google.com/forum/?fromgroups#!forum/shake-build-system">Email us</a> for any questions/bugs/thoughts on Shake. If you need more information and aren&#39;t sure where to start, use the mailing list.</li></ul><h4>Q: Is Shake limited to building Haskell?</h4><p>Not at all -- Shake can build any project in any combination of languages. In fact, Shake isn&#39;t typically necessary for vanilla Haskell projects, as you can use <a href="https://haskell.org/cabal"><code>cabal</code></a> or <a href="https://haskellstack.org/"><code>stack</code></a>. Shake is often used for building C/C++, Docker containers and Javascript/HTML/CSS projects.</p><h4>Q: Where are functions for string manipulation?</h4><p>Shake is a Haskell package focused on providing build-system functionality. Since Shake scripts are written in Haskell, they can easily access other Haskell packages. Most general needs are met by the standard <a href="https://hackage.haskell.org/package/base"><code>base</code> library</a>, but a few other useful general functions can be found in <a href="https://hackage.haskell.org/package/extra">the <code>extra</code> library</a> (e.g. <a href="https://hackage.haskell.org/package/extra/docs/Data-List-Extra.html#v:trim"><code>trim</code></a> and <a href="https://hackage.haskell.org/package/extra/docs/Data-List-Extra.html#v:replace"><code>replace</code></a>). For more specific functionality (e.g. parsing, databases, JSON) find a <a href="https://hackage.haskell.org/packages">suitable Haskell library</a> and use that.</p><h4>Q: Why is there a <code>shake</code> executable?</h4><p>Most users will write their own Haskell file and compile it to produce an executable that is their build tool. The <code>shake</code> executable is there to <a href="Demo.md">run the demo</a>, run <a href="Ninja.md">Ninja build files</a> and will also run a <code>Shakefile.hs</code> if present.</p><h4>Q: Can file patterns overlap?</h4><p>No. If two patterns overlap for a file being built it will result in a runtime error -- you cannot have a pattern for <code>*.txt</code>, and another for <code>foo.*</code>, and then build a file named <code>foo.txt</code>. For objects that typically share the same extension (e.g. C and Haskell both produce <code>.o</code> objects), either disambiguate with a different extension (e.g. <code>.c.o</code> and <code>.hs.o</code>), or different directory (e.g. <code>obj/c/**/.o</code> and <code>obj/hs/**/.o</code>). For more information, including ways to enable overlap and set priorities, see <code>%&gt;</code>.</p><h4>Q: Why do multiple calls to <code>need</code> run sequentially? Are <code>Applicative</code> actions run in parallel?</h4><p>In Shake, <code>need xs &gt;&gt; need ys</code> will build <code>xs</code> in parallel, then afterwards build <code>ys</code> in parallel. The same is true of <code>need xs *&gt; need ys</code>, where <code>*&gt;</code> is the applicative equivalent of <code>&gt;&gt;</code>. In contrast, <a href="https://hackage.haskell.org/package/haxl">Haxl</a> will execute both arguments to <code>*&gt;</code> in parallel. For Shake, you are encouraged to merge adjacent <code>need</code> operations (e.g. <code>need (xs++ys)</code>), and where that is not possible (e.g. when using <code>askOracle</code>) use <code>parallel</code> explicitly.</p><p>Shake <i>could</i> follow the Haxl approach, but does not, mainly because they are targeting different problems. In Haxl, the operations are typically read-only, and any single step is likely to involve lots of operations. In contrast, with Shake the operations definitely change the file system, and there are typically only one or two per rule. Consequently, Shake opts for an explicit approach, rather than allow users to use <code>*&gt;</code> (and then inevitably add a comment because its an unusual thing to do).</p><h4>Q: Should file names be relative or absolute?</h4><p>We recommend using only relative file names in Shake.</p><p>Shake can use file names that are either absolute (<code>C:\file.txt</code>, <code>/file.txt</code>) or relative (<code>file.txt</code>). However, Shake compares filenames by value, so if you <code>need</code> both <code>file.txt</code> and <code>/file.txt</code> it will attempt to build both, likely resulting in failure - within a single Shake project you must stick to either relative or absolute file names.</p><h4>Q: How can I depend on directories?</h4><p>Think of directories as containers for files. They exist or don&#39;t pretty randomly, but if they have files, they must exist. In particular, you can&#39;t depend on a directory with <code>need</code> or write a rule to create a directory. Directories are created as needed -- the rule for <code>bar/baz.exe</code> will create the <code>bar</code> directory if necessary. If you want to depend on a <code>git clone</code> having being performed, depend on a particular checked-out file instead (e.g. <code>README.md</code>), with the rule to create it being <code>git clone</code>.</p><p>There is a tracked function <code>doesDirectoryExist</code>, to depend on the presence or absence of a directory, but you should not call it on directories which might be created by the build system.</p><h4>Q: What GHC bugs has Shake found?</h4><p>For some reason, Shake tends to find a reasonable number of serious bugs in GHC, given how few bugs there are generally in GHC. I suspect the reason is a combination of thorough testing including with GHC pre-releases. Some of the best bugs found by Shake are:</p><ul><li><a href="https://ghc.haskell.org/trac/ghc/ticket/7646">GHC bug 7646</a>, a race condition when closing file handles that had been in several releases.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/10830">GHC bug 10830</a>, <code>maximumBy</code> had a space leak in a released version.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/11555">GHC bug 11555</a>, <code>catch</code> wouldn&#39;t catch an <code>undefined</code> argument passed to it in a pre-release.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/11830">GHC bug 11830</a>, livelock when disabling idle GC in a pre-release.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/11458">GHC bug 11458</a> (originally from <a href="https://ghc.haskell.org/trac/ghc/ticket/11379">GHC bug 11379</a>), serious issue with type applications producing dodgy programs in a pre-release.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/11978">GHC bug 11978</a>, segfaults when running certain profiling modes that weren&#39;t multithread safe.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/10553">GHC bug 10553</a>, <code>getEnvironment</code> was blank when run on PowerPC in <code>ghci</code>.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/10549">GHC bug 10549</a>, inconsistent optimisation flags leading to fatal errors in a pre-release.</li><li><a href="https://ghc.haskell.org/trac/ghc/ticket/10176">GHC bug 10176</a>, invalid optimisations caused by a part of GHC that had been formally proved to be correct, in a pre-release.</li></ul><h4>Q: What&#39;s the history of Shake?</h4><p>I (<a href="https://ndmitchell.com">Neil Mitchell</a>) was one of the people behind the <a href="https://www.haskell.org/haskellwiki/Yhc">Yhc project</a>, a Haskell compiler that died in a large part because of its build system. To quote from <a href="https://yhc06.blogspot.co.uk/2011/04/yhc-is-dead.html">the final blog post</a>:</p><blockquote><p>The biggest challenge for Yhc was the build system -- we ended up with 10,000 lines of Python Scons scripts. Without a robust build system nothing else matters. When our sole Python hacker left the team that was the beginning of the end.</p></blockquote><p>A Haskell compiler is a big undertaking, but the build system for a simple Haskell compiler shouldn&#39;t be that complicated.</p><p>When writing my thesis I needed a build system, and decided to try writing a simple Haskell DSL, which is still online <a href="https://github.com/ndmitchell/thesis/blob/master/old/Main.hs">here</a>. I defined a single operator <a href="https://github.com/ndmitchell/thesis/blob/master/old/Main.hs#L71"><code>&lt;==</code></a> which let me express a relationship between an output and its dependencies -- very simple, but it worked.</p><p>Later I moved to <a href="https://www.sc.com/">Standard Chartered</a>, where the build system was a mass of Makefiles, and it quickly became apparent that the project had outgrown the current approach. Without really surveying the alternatives, I decided that a Haskell DSL would be easiest to fit in with the existing infrastructure, so started writing some code. The first version of the build library took under a week, followed by a month of reimplementing the existing system. It wasn&#39;t until many months later I realised that the reason everything was suddenly so much easier was because we had monadic dependencies.</p><p>While people at Standard Chartered wanted to open source Shake, that turned out not to be possible. A number of people in the Haskell community implemented their own versions of Shake, but none were as polished or as strong as our internal one. Eventually, I reimplemented Shake, from scratch, in my spare time. Writing Shake from scratch, without the original source code or documentation, it naturally turned out better than the first attempt. A while later Standard Chartered migrated to the open-source version.</p><p>I still maintain Shake, but am fortunate to have <a href="https://github.com/ndmitchell/shake/graphs">other contributors</a> extending and improving Shake. If you want to join in, see <a href="Developing.md">notes for developers</a>.</p>--></div><p id="footer">
    Questions? Feedback?
    <a href="https://groups.google.com/forum/?fromgroups#!forum/shake-build-system">Email us</a>.
    Collaborate through <a href="https://github.com/ndmitchell/shake">GitHub</a>.
    Ask at <a href="https://stackoverflow.com/questions/tagged/shake-build-system">StackOverflow</a>.
</p>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-286191-4', 'auto');
ga('send', 'pageview');
</script>

</body>
</html>
