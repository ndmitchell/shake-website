<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"></meta>
        <meta http-equiv="X-UA-Compatible" content="chrome=1"></meta>
        <meta name="viewport" content="width=device-width"></meta>
        <!-- favicon from https://findicons.com/icon/445768/blue_lego?id=445922 -->
        <link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link>
        <title>Shake Build System</title>
        <link rel="stylesheet" href="index.css"></link>



    </head>
    <body class="page-manual">

<div id="header">
    <a href="https://shakebuild.com" id="header-root">Shake build system</a>
    <a href="." id="header-first">Home</a>
    <a href="why">Why Shake</a>
    <a class="active" href="manual">Manual</a>
    <a href="faq">FAQ</a>
</div>

<div id="content"><div id="toc"><a class="h2" href="#basic-syntax">Basic syntax</a><a class="h2" href="#advanced-syntax">Advanced Syntax</a><a class="h2" href="#running">Running</a><a class="h2" href="#extensions">Extensions</a><a class="h2" href="#the-haskell-zone">The Haskell Zone</a></div><h1>Shake Manual</h1>
<p>Shake is a Haskell library for writing build systems &ndash; designed as a replacement for <code>make</code>. This document describes how to get started with Shake, assuming no prior Haskell knowledge. First, let's take a look at a Shake build system:</p>
<pre><span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html">Development.Shake</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Command.html">Development.Shake.Command</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html">Development.Shake.FilePath</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html">Development.Shake.Util</a>

main <span class="sym">::</span> IO <span class="sym">(</span><span class="sym">)</span>
main <span class="sym">=</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeArgs">shakeArgs</a> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a><span class="sym">{</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeFiles">shakeFiles</a><span class="sym">=</span><span class="str">&quot;_build&quot;</span><span class="sym">}</span> $ <span class="key">do</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a> <span class="sym">[</span><span class="str">&quot;_build/run&quot;</span> &lt;.&gt; <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:exe">exe</a><span class="sym">]</span>

    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:phony">phony</a> <span class="str">&quot;clean&quot;</span> $ <span class="key">do</span>
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:putNormal">putNormal</a> <span class="str">&quot;Cleaning files in _build&quot;</span>
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:removeFilesAfter">removeFilesAfter</a> <span class="str">&quot;_build&quot;</span> <span class="sym">[</span><span class="str">&quot;//*&quot;</span><span class="sym">]</span>

    <span class="str">&quot;_build/run&quot;</span> &lt;.&gt; <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:exe">exe</a> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
        cs <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a> <span class="str">&quot;&quot;</span> <span class="sym">[</span><span class="str">&quot;//*.c&quot;</span><span class="sym">]</span>
        <span class="key">let</span> os <span class="sym">=</span> <span class="sym">[</span><span class="str">&quot;_build&quot;</span> &lt;/&gt; c -&lt;.&gt; <span class="str">&quot;o&quot;</span> <span class="sym">|</span> c <span class="sym">&lt;-</span> cs<span class="sym">]</span>
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> os
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -o&quot;</span> <span class="sym">[</span>out<span class="sym">]</span> os

    <span class="str">&quot;_build//*.o&quot;</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
        <span class="key">let</span> c <span class="sym">=</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:dropDirectory1">dropDirectory1</a> $ out -&lt;.&gt; <span class="str">&quot;c&quot;</span>
        <span class="key">let</span> m <span class="sym">=</span> out -&lt;.&gt; <span class="str">&quot;m&quot;</span>
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -c&quot;</span> <span class="sym">[</span>c<span class="sym">]</span> <span class="str">&quot;-o&quot;</span> <span class="sym">[</span>out<span class="sym">]</span> <span class="str">&quot;-MMD -MF&quot;</span> <span class="sym">[</span>m<span class="sym">]</span>
        <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html#v:needMakefileDependencies">needMakefileDependencies</a> m</code></pre>
<p>This build system builds the executable <code>_build/run</code> from all C source files in the current directory. It will rebuild if you add/remove any C files to the directory, if the C files themselves change, or if any headers used by the C files change. All generated files are placed in <code>_build</code>, and a <code>clean</code> command is provided that will wipe all the generated files. In the rest of this manual we'll explain how the above code works and how to extend it.</p>
<span class="target" id="running-this-example"></span><h4><a href="#running-this-example" class="anchor">Running this example</a></h4>
<p>To run the example above:</p>
<ol><li>Install the <a href="https://haskellstack.org/">Haskell Stack</a>, which provides a Haskell compiler and package manager.</li>
<li>Type <code>stack install shake</code>, to build and install Shake and all its dependencies.</li>
<li>Type <code>stack exec -- shake --demo</code>, which will create a directory containing a sample project, the above Shake script (named <code>Build.hs</code>), and execute it (which can be done by <code>runhaskell Build.hs</code>). For more details see a <a href="./demo">trace of <code>shake --demo</code></a>.</li>
</ol>
<span class="target" id="basic-syntax"></span><h2><a href="#basic-syntax" class="anchor">Basic syntax</a></h2>
<p>This section explains enough syntax to write a basic Shake build script.</p>
<span class="target" id="boilerplate"></span><h4><a href="#boilerplate" class="anchor">Boilerplate</a></h4>
<p>The build system above starts with the following boilerplate:</p>
<pre>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html">Development.Shake</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Command.html">Development.Shake.Command</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html">Development.Shake.FilePath</a>
<span class="key">import</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html">Development.Shake.Util</a>
 
main <span class="sym">::</span> IO <span class="sym">(</span><span class="sym">)</span>
main <span class="sym">=</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeArgs">shakeArgs</a> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a><span class="sym">{</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeFiles">shakeFiles</a><span class="sym">=</span><span class="str">&quot;_build&quot;</span><span class="sym">}</span> $ <span class="key">do</span>
    <i>build rules</i>
</pre>
<p>All the interesting build-specific code is placed under <tt><i>build rules</i></tt>. Many build systems will be able to reuse that boilerplate unmodified.</p>
<span class="target" id="defining-targets"></span><h4><a href="#defining-targets" class="anchor">Defining targets</a></h4>
<p>A target is a file we want the build system to produce (typically executable files). For example, if we want to produce the file <code>manual/examples.txt</code> we can write:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a> <span class="sym">[</span><span class="str">&quot;manual/examples.txt&quot;</span><span class="sym">]</span></code></pre>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a></code> function takes a list of strings. In Shake lists are written <code><span class="sym">[</span>item1,item2,item2<span class="sym">]</span></code> and strings are written <code><span class="str">&quot;contents of a string&quot;</span></code>. Special characters in strings can be escaped using <code>\</code> (e.g. <code><span class="str">&quot;\n&quot;</span></code> for newline) and directory separators are always written <code>/</code>, even on Windows.</p>
<p>Most files have the same name on all platforms, but executable files on Windows usually have the <code>.exe</code> extension, while on POSIX they have no extension. When writing cross-platform build systems (like the initial example), we can write:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a> <span class="sym">[</span><span class="str">&quot;_build/run&quot;</span> &lt;.&gt; <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:exe">exe</a><span class="sym">]</span></code></pre>
<p>The <code>&lt;.&gt;</code> function adds an extension to a file path, and the built-in <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:exe">exe</a></code> variable evaluates to <code><span class="str">&quot;exe&quot;</span></code> on Windows and <code><span class="str">&quot;&quot;</span></code> otherwise.</p>
<span class="target" id="defining-rules"></span><h4><a href="#defining-rules" class="anchor">Defining rules</a></h4>
<p>A rule describes the steps required to build a file. A rule has two components, a <tt><i>pattern</i></tt> and some <tt><i>actions</i></tt>:</p>
<pre>
<i>pattern</i> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
    <i>actions</i>
</pre>
<p>The <tt><i>pattern</i></tt> is a string saying which files this rule can build. It may be a specific file (e.g.  <code>&quot;manual/examples.txt&quot; %&gt; ...</code>) or may use wildcards:</p>
<ul><li>The <code>*</code> wildcard matches anything apart from a directory separator. For example <code><span class="str">&quot;manual/*.txt&quot;</span></code> would define a rule for any <code>.txt</code> file in the <code>manual</code> directory, including <code>manual/examples.txt</code>, but would not match <code>manual/examples.zip</code>, <code>examples.txt</code> or <code>manual/docs/examples.txt</code>.</li>
<li>The <code>//</code> wildcard matches any number of complete path components. For example <code>//*.txt</code> would define a rule for any <code>.txt</code> file, including <code>manual/examples.txt</code>. As another example, <code>manual//examples.txt</code> would match any file named <code>examples.txt</code> inside <code>manual</code>, including both <code>manual/examples.txt</code> and <code>manual/docs/examples.txt</code>.</li>
</ul>
<p>It is an error for multiple patterns to match a file being built, so you should keep patterns minimal. Looking at the two rules in the initial example:</p>
<pre>&quot;_build/run&quot; &lt;.&gt; exe %&gt; ...
&quot;_build//*.o&quot; %&gt; ...</code></pre>
<p>The first matches only the <code>run</code> executable, using <code>&lt;.&gt; <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:exe">exe</a></code> to ensure the executable is correctly named on all platforms. The second matches any <code>.o</code> file anywhere under <code>_build</code>. As examples, <code>_build/main.o</code> and <code>_build/foo/bar.o</code> both match while <code>main.o</code> and <code>_build/main.txt</code> do not.</p>
<p>Lots of compilers produce <code>.o</code> files, so if you are combining two different languages, say C and Haskell, use the extension <code>.c.o</code> and <code>.hs.o</code> to avoid overlapping rules.</p>
<p>The <tt><i>actions</i></tt> are a list of steps to perform and are listed one per line, indented beneath the rule. Actions both express dependencies (say what this rule uses) and run commands (actually generate the file). During the action the <code>out</code> variable is bound to the file that is being produced.</p>
<span class="target" id="a-simple-rule"></span><h4><a href="#a-simple-rule" class="anchor">A simple rule</a></h4>
<p>Let's look at a simple example of a rule:</p>
<pre><span class="str">&quot;*.rot13&quot;</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
    <span class="key">let</span> src <span class="sym">=</span> out -&lt;.&gt; <span class="str">&quot;txt&quot;</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span>src<span class="sym">]</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;rot13&quot;</span> src <span class="str">&quot;-o&quot;</span> out</code></pre>
<p>This rule can build any <code>.rot13</code> file. Imagine we are building <code><span class="str">&quot;file.rot13&quot;</span></code>, it proceeds by:</p>
<ul><li>Using <code><span class="key">let</span></code> to define a local variable <code>src</code>, using the <code>-&lt;.&gt;</code> extension replacement method, which removes the extension from a file and adds a new extension. When <code>out</code> is <code><span class="str">&quot;file.rot13&quot;</span></code> the variable <code>src</code> will become <code>file.txt</code>.</li>
<li>Using <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a></code> to introduce a dependency on the <code>src</code> file, ensuring that if <code>src</code> changes then <code>out</code> will be rebuilt and that <code>src</code> will be up-to-date before any further commands are run.</li>
<li>Using <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> to run the command line <code>rot13 file.txt -o file.rot13</code>, which should read <code>file.txt</code> and write out <code>file.rot13</code> being the ROT13 encoding of the file.</li>
</ul>
<p>Many rules follow this pattern &ndash; calculate some local variables, <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a></code> some dependencies, then use <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> to perform some actions. We now discuss each of the three statements.</p>
<span class="target" id="local-variables"></span><h4><a href="#local-variables" class="anchor">Local variables</a></h4>
<p>Local variables can be defined as:</p>
<pre>
<span class="key">let</span> <i>variable</i> <span class="sym">=</span> <i>expression</i>
</pre>
<p>Where <tt><i>variable</i></tt> is a name consisting of letters, numbers and underscores (a-z, A-Z, 0-9 and _). All variables <i>must</i> start with a lower-case letter.</p>
<p>An <tt><i>expression</i></tt> is any combination of variables and function calls, for example <code>out -&lt;.&gt; <span class="str">&quot;txt&quot;</span></code>. A list of some common functions is discussed later.</p>
<p>Variables are evaluated by substituting the <tt><i>expression</i></tt> everywhere the <tt><i>variable</i></tt> is used. In the simple example we could have equivalently written:</p>
<pre><span class="str">&quot;*.rot13&quot;</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span>out -&lt;.&gt; <span class="str">&quot;txt&quot;</span><span class="sym">]</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;rot13&quot;</span> <span class="sym">(</span>out -&lt;.&gt; <span class="str">&quot;txt&quot;</span><span class="sym">)</span> <span class="str">&quot;-o&quot;</span> out</code></pre>
<p>Variables are local to the rule they are defined in, cannot be modified, and should not be defined multiple times within a single rule.</p>
<span class="target" id="file-dependencies"></span><h4><a href="#file-dependencies" class="anchor">File dependencies</a></h4>
<p>You can express a dependency on a file with:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span><span class="str">&quot;file.src&quot;</span><span class="sym">]</span></code></pre>
<p>To depend on multiple files you can write:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span><span class="str">&quot;file.1&quot;</span>,<span class="str">&quot;file.2&quot;</span><span class="sym">]</span></code></pre>
<p>Or alternatively:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span><span class="str">&quot;file.1&quot;</span><span class="sym">]</span>
<a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span><span class="str">&quot;file.2&quot;</span><span class="sym">]</span></code></pre>
<p>It is preferable to use fewer calls to <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a></code>, if possible, as multiple files required by a <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a></code> can be built in parallel.</p>
<span class="target" id="running-external-commands"></span><h4><a href="#running-external-commands" class="anchor">Running external commands</a></h4>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> function allows you to call system commands, e.g. <code>gcc</code>. Taking the initial example, we see:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -o&quot;</span> <span class="sym">[</span>out<span class="sym">]</span> os</code></pre>
<p>After substituting <code>out</code> (a string variable) and <code>os</code> (a list of strings variable) we might get:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -o&quot;</span> <span class="sym">[</span><span class="str">&quot;_make/run&quot;</span><span class="sym">]</span> <span class="sym">[</span><span class="str">&quot;_build/main.o&quot;</span>,<span class="str">&quot;_build/constants.o&quot;</span><span class="sym">]</span></code></pre>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> function takes any number of space-separated expressions. Each expression can be either a string (which is treated as a space-separated list of arguments) or a list of strings (which is treated as a direct list of arguments).  Therefore the above command line is equivalent to either of:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -o _make/run _build/main.o _build/constants.o&quot;</span>
<a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="sym">[</span><span class="str">&quot;gcc&quot;</span>,<span class="str">&quot;-o&quot;</span>,<span class="str">&quot;_make/run&quot;</span>,<span class="str">&quot;_build/main.o&quot;</span>,<span class="str">&quot;_build/constants.o&quot;</span><span class="sym">]</span></code></pre>
<p>To properly handle unknown string variables it is recommended to enclose them in a list, e.g. <code><span class="sym">[</span>out<span class="sym">]</span></code>, so that even if <code>out</code> contains a space it will be treated as a single argument.</p>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> function as presented here will fail if the system command returns a non-zero exit code, but see later for how to treat failing commands differently.</p>
<span class="target" id="filepath-manipulation-functions"></span><h4><a href="#filepath-manipulation-functions" class="anchor">Filepath manipulation functions</a></h4>
<p>Shake provides a complete library of filepath manipulation functions (see the <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html">docs for <code>Development.Shake.FilePath</code></a>), but the most common are:</p>
<ul><li><code>str1 &lt;/&gt; str2</code> &ndash; add the path components together with a slash, e.g. <code><span class="str">&quot;_build&quot;</span> &lt;/&gt; <span class="str">&quot;main.o&quot;</span></code> equals <code><span class="str">&quot;_build/main.o&quot;</span></code>.</li>
<li><code>str1 &lt;.&gt; str2</code> &ndash; add an extension, e.g. <code><span class="str">&quot;main&quot;</span> &lt;.&gt; <span class="str">&quot;o&quot;</span></code> equals <code><span class="str">&quot;main.o&quot;</span></code>.</li>
<li><code>str1 ++ str2</code> &ndash; append two strings together, e.g. <code><span class="str">&quot;hello&quot;</span> ++ <span class="str">&quot;world&quot;</span></code> equals <code><span class="str">&quot;helloworld&quot;</span></code>.</li>
<li><code>str1 -&lt;.&gt; str2</code> &ndash; replace an extension, e.g. <code><span class="str">&quot;main.c&quot;</span> -&lt;.&gt; <span class="str">&quot;o&quot;</span></code> equals <code><span class="str">&quot;main.o&quot;</span></code>.</li>
<li><code>dropExtension str</code> &ndash; drop the final extension of a filepath if it has one, e.g. <code>dropExtension <span class="str">&quot;main.o&quot;</span></code> equals <code><span class="str">&quot;main&quot;</span></code>, while <code>dropExtension <span class="str">&quot;main&quot;</span></code> equals <code><span class="str">&quot;main&quot;</span></code>.</li>
<li><code>takeFileName str</code> &ndash; drop the path component, e.g. <code>takeFileName <span class="str">&quot;_build/src/main.o&quot;</span></code> equals <code><span class="str">&quot;main.o&quot;</span></code>.</li>
<li><code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:dropDirectory1">dropDirectory1</a> str</code> &ndash; drop the first path component, e.g. <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:dropDirectory1">dropDirectory1</a> <span class="str">&quot;_build/src/main.o&quot;</span></code> equals <code><span class="str">&quot;src/main.o&quot;</span></code>.</li>
</ul>
<span class="target" id="advanced-syntax"></span><h2><a href="#advanced-syntax" class="anchor">Advanced Syntax</a></h2>
<p>The following section covers more advanced operations that are necessary for moderately complex build systems, but not simple ones.</p>
<span class="target" id="directory-listing-dependencies"></span><h4><a href="#directory-listing-dependencies" class="anchor">Directory listing dependencies</a></h4>
<p>The function <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a></code> can retrieve a list of files within a directory:</p>
<pre>files <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a> <span class="str">&quot;&quot;</span> <span class="sym">[</span><span class="str">&quot;//*.c&quot;</span><span class="sym">]</span></code></pre>
<p>After this operation <code>files</code> will be a variable containing all the files matching the pattern <code><span class="str">&quot;//*.c&quot;</span></code> (those with the extension <code>.c</code>) starting at the directory <code><span class="str">&quot;&quot;</span></code> (the current directory). To obtain all <code>.c</code> and <code>.cpp</code> files in the src directory we can write:</p>
<pre>files <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a> <span class="str">&quot;src&quot;</span> <span class="sym">[</span><span class="str">&quot;//*.c&quot;</span>,<span class="str">&quot;//*.cpp&quot;</span><span class="sym">]</span></code></pre>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a></code> operation is tracked by the build system, so if the files in a directory change the rule will rebuild in the next run. You should only use <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getDirectoryFiles">getDirectoryFiles</a></code> on source files, not files that are generated by the build system, otherwise the results will change while you are running the build and the build may be inconsistent.</p>
<span class="target" id="list-manipulations"></span><h4><a href="#list-manipulations" class="anchor">List manipulations</a></h4>
<p>Many functions work with lists of values. The simplest operation on lists is to join two lists together, which we do with <code>++</code>. For example, <code><span class="sym">[</span><span class="str">&quot;main.c&quot;</span><span class="sym">]</span> ++ <span class="sym">[</span><span class="str">&quot;constants.c&quot;</span><span class="sym">]</span></code> equals <code><span class="sym">[</span><span class="str">&quot;main.c&quot;</span>, <span class="str">&quot;constants.c&quot;</span><span class="sym">]</span></code>.</p>
<p>Using a <i>list comprehension</i> we can produce new lists, apply functions to the elements and filtering them. As an example:</p>
<pre><span class="sym">[</span><span class="str">&quot;_build&quot;</span> &lt;/&gt; x -&lt;.&gt; <span class="str">&quot;o&quot;</span> <span class="sym">|</span> x <span class="sym">&lt;-</span> inputs<span class="sym">]</span></code></pre>
<p>This expression grabs each element from <code>inputs</code> and names it <code>x</code> (the <code>x <span class="sym">&lt;-</span> inputs</code>, pronounced &quot;<code>x</code> is drawn from <code>inputs</code>&quot;), then applies the expression  <code><span class="str">&quot;_build&quot;</span> &lt;/&gt; x -&lt;.&gt; <span class="str">&quot;o&quot;</span></code> to each element. If we start with the list <code><span class="sym">[</span><span class="str">&quot;main.c&quot;</span>,<span class="str">&quot;constants.c&quot;</span><span class="sym">]</span></code>, we would end up with <code><span class="sym">[</span><span class="str">&quot;_build/main.o&quot;</span>, <span class="str">&quot;_build/constants.o&quot;</span><span class="sym">]</span></code>.</p>
<p>List expressions also allow us to filter the list, for example we could know that the file <code><span class="str">&quot;evil.c&quot;</span></code> is in the directory, but should not be compiled. We can extend that to:</p>
<pre><span class="sym">[</span><span class="str">&quot;_build&quot;</span> &lt;/&gt; x -&lt;.&gt; <span class="str">&quot;o&quot;</span> <span class="sym">|</span> x <span class="sym">&lt;-</span> inputs, x <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Classes.html#v:-47--61-">/=</a> <span class="str">&quot;evil.c&quot;</span><span class="sym">]</span></code></pre>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Classes.html#v:-47--61-">/=</a></code> operator checks for inequality, and any predicate after the drawn from is used to first restrict which elements of the list are available.</p>
<span class="target" id="using-gcc-to-collect-headers"></span><h4><a href="#using-gcc-to-collect-headers" class="anchor">Using <code>gcc</code> to collect headers</a></h4>
<p>One common problem when building <code>.c</code> files is tracking down which headers they transitively import, and thus must be added as a dependency. We can solve this problem by asking <code>gcc</code> to create a file while building that contains a list of all the imports. If we run:</p>
<pre>gcc -c main.c -o main.o -MMD -MF main.m</code></pre>
<p>That will compile <code>main.c</code> to <code>main.o</code>, and also produce a file <code>main.m</code> containing the dependencies. To add these dependencies as dependencies of this rule we can call:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html#v:needMakefileDependencies">needMakefileDependencies</a> <span class="str">&quot;main.m&quot;</span></code></pre>
<p>Now, if either <code>main.c</code> or any headers transitively imported by <code>main.c</code> change, the file will be rebuilt. In the initial example the complete rule is:</p>
<pre><span class="str">&quot;_build//*.o&quot;</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
    <span class="key">let</span> c <span class="sym">=</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-FilePath.html#v:dropDirectory1">dropDirectory1</a> $ out -&lt;.&gt; <span class="str">&quot;c&quot;</span>
    <span class="key">let</span> m <span class="sym">=</span> out -&lt;.&gt; <span class="str">&quot;m&quot;</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -c&quot;</span> <span class="sym">[</span>c<span class="sym">]</span> <span class="str">&quot;-o&quot;</span> <span class="sym">[</span>out<span class="sym">]</span> <span class="str">&quot;-MMD -MF&quot;</span> <span class="sym">[</span>m<span class="sym">]</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html#v:needMakefileDependencies">needMakefileDependencies</a> m</code></pre>
<p>We first compute the source file <code>c</code> (e.g. <code><span class="str">&quot;main.c&quot;</span></code>) that is associated with the <code>out</code> file (e.g. <code><span class="str">&quot;_build/main.o&quot;</span></code>). We then compute a temporary file <code>m</code> to write the dependencies to (e.g. <code><span class="str">&quot;_build/main.m&quot;</span></code>). We then call <code>gcc</code> using the <code>-MMD -MF</code> flags and then finally call <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Util.html#v:needMakefileDependencies">needMakefileDependencies</a></code>.</p>
<span class="target" id="toplevel-variables"></span><h4><a href="#toplevel-variables" class="anchor">Top-level variables</a></h4>
<p>Variables local to a rule are defined using <code><span class="key">let</span></code>, but you can also define top-level variables. Top-level variables are defined before the <code>main</code> call, for example:</p>
<pre>buildDir <span class="sym">=</span> <span class="str">&quot;_build&quot;</span></code></pre>
<p>You can now use <code>buildDir</code> in place of <code><span class="str">&quot;_build&quot;</span></code> throughout. You can also define parametrised variables (functions) by adding argument names:</p>
<pre>buildDir x <span class="sym">=</span> <span class="str">&quot;_build&quot;</span> &lt;/&gt; x</code></pre>
<p>We can now write:</p>
<pre>buildDir (&quot;run&quot; &lt;.&gt; exe) %&gt; \out -&gt; do
    ...</code></pre>
<p>All top-level variables and functions can be thought of as being expanded wherever they are used, although in practice may have their evaluation shared.</p>
<span class="target" id="a-clean-command"></span><h4><a href="#a-clean-command" class="anchor">A clean command</a></h4>
<p>A standard clean command is defined as:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:phony">phony</a> <span class="str">&quot;clean&quot;</span> $ <span class="key">do</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:putNormal">putNormal</a> <span class="str">&quot;Cleaning files in _build&quot;</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:removeFilesAfter">removeFilesAfter</a> <span class="str">&quot;_build&quot;</span> <span class="sym">[</span><span class="str">&quot;//*&quot;</span><span class="sym">]</span></code></pre>
<p>Running the build system with the <code>clean</code> argument, e.g. <code>runhaskell Build.hs clean</code> will remove all files under the <code>_build</code> directory. This clean command is formed from two separate pieces. Firstly, we can define <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:phony">phony</a></code> commands as:</p>
<pre>
<a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:phony">phony</a> <span class="str">&quot;</span><i>name</i><span class="str">&quot;</span> $ <span class="key">do</span>
    <i>actions</i>
</pre>
<p>Where <tt><i>name</i></tt> is the name used on the command line to invoke the actions, and <tt><i>actions</i></tt> are the list of things to do in response. These names are not dependency tracked and are run afresh each time they are requested.</p>
<p>The <tt><i>actions</i></tt> can be any standard build actions, although for a <code>clean</code> rule, <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:removeFilesAfter">removeFilesAfter</a></code> is typical. This function waits until after any files have finished building (which will be none, if you do <code>runhaskell Build.hs clean</code>) then deletes all files matching <code>//*</code> in the <code>_build</code> directory. The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:putNormal">putNormal</a></code> function writes out a message to the console, as long as <code>--quiet</code> was not passed.</p>
<span class="target" id="running"></span><h2><a href="#running" class="anchor">Running</a></h2>
<p>This section covers how to run the build system you have written.</p>
<span class="target" id="compiling-the-build-system"></span><h4><a href="#compiling-the-build-system" class="anchor">Compiling the build system</a></h4>
<p>As shown before, we can use <code>runhaskell Build.hs</code> to execute our build system, but doing so causes the build script to be compiled afresh each time. A more common approach is to add a shell script that compiles the build system and runs it. In the example directory you will find <code>build.sh</code> (Linux) and <code>build.bat</code> (Windows), both of which execute the same interesting commands. Looking at <code>build.sh</code>:</p>
<pre>#!/bin/sh
mkdir -p _shake
ghc --make Build.hs -rtsopts -threaded -with-rtsopts=-I0 -outputdir=_shake -o _shake/build &amp;&amp; _shake/build &quot;$@&quot;</code></pre>
<p>This script creates a folder named <code>_shake</code> for the build system objects to live in, then runs <code>ghc --make Build.hs</code> to produce <code>_shake/build</code>, then executes <code>_shake/build</code> with all arguments it was given. The <code>-with-rtsopts</code> flag instructs the Haskell compiler to disable &quot;idle garbage collection&quot;, making more CPU available for the commands you are running, as <a href="https://stackoverflow.com/questions/34588057/why-does-shake-recommend-disabling-idle-garbage-collection/">explained here</a>.</p>
<p>Now you can run a build by typing <code>stack exec ./build.sh</code> on Linux, or <code>stack exec build.bat</code> on Windows. On Linux you may want to alias <code>build</code> to <code>stack exec ./build.sh</code>. For the rest of this document we will assume <code>build</code> runs the build system.</p>
<p><i>Warning:</i> You should not use the <code>-threaded</code> for GHC 7.6 or below because of a <a href="https://ghc.haskell.org/trac/ghc/ticket/7646">GHC bug</a>. If you do turn on <code>-threaded</code>, you should include <code>-qg</code> in <code>-with-rtsopts</code>.</p>
<span class="target" id="command-line-flags"></span><h4><a href="#command-line-flags" class="anchor">Command line flags</a></h4>
<p>The initial example build system supports a number of command line flags, including:</p>
<ul><li><code>build</code> will compile all files required by <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a></code>.</li>
<li><code>build _build/main.o</code> will compile enough to create <code>_build/main.o</code>, ignoring all <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:want">want</a></code> requirements.</li>
<li><code>build clean</code> will delete the contents of <code>_build</code>, because of our <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:phony">phony</a></code> command.</li>
<li><code>build --help</code> will list out all flags supported by the build system, currently 36 flags. Most flags supported by <code>make</code> are also supported by Shake based build systems.</li>
<li><code>build -j8</code> will compile up to 8 rules simultaneously, by default Shake uses 1 processor.</li>
</ul>
<p>Most flags can also be set within the program by modifying the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a></code> value. As an example, <code>build --metadata<span class="sym">=</span>_metadata</code> causes all Shake metadata files to be stored with names such as <code>_metadata/.shake.database</code>. Alternatively we can write <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a><span class="sym">{</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeFiles">shakeFiles</a><span class="sym">=</span><span class="str">&quot;_metadata&quot;</span><span class="sym">}</span></code> instead of our existing <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeFiles">shakeFiles</a><span class="sym">=</span><span class="str">&quot;_build&quot;</span></code>. Values passed on the command line take preference over those given by <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a></code>. Multiple overrides can be given to <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a></code> by separating them with a comma, for example <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a><span class="sym">{</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeFiles">shakeFiles</a><span class="sym">=</span><span class="str">&quot;_build&quot;</span>, <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeThreads">shakeThreads</a><span class="sym">=</span>8<span class="sym">}</span></code>.</p>
<span class="target" id="progress"></span><span class="target" id="progress-prediction"></span><h4><a href="#progress-prediction" class="anchor">Progress prediction</a></h4>
<p>One useful feature of Shake is that it can predict the remaining build time, based on how long previous builds have taken. The number is only a prediction, but it does take account of which files require rebuilding, how fast your machine is currently running, parallelism settings etc. You can display progress messages in the titlebar of a Window by either:</p>
<ul><li>Running <code>build --progress</code></li>
<li>Setting <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeOptions">shakeOptions</a><span class="sym">{</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeProgress">shakeProgress</a> <span class="sym">=</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:progressSimple">progressSimple</a><span class="sym">}</span></code></li>
</ul>
<p>The progress message will be displayed in the titlebar of the window, for example <code>3m12s (82%)</code> to indicate that the build is 82% complete and is predicted to take a further 3 minutes and 12 seconds. If you are running Windows 7 or higher and place the <a href="https://github.com/ndmitchell/shake/releases/tag/shake-progress-1"><code>shake-progress</code></a> utility somewhere on your <code>%PATH%</code> then the progress will also be displayed in the taskbar progress indicator:</p>
<p><img src="shake-progress.png" alt></p>
<p>Progress prediction is likely to be relatively poor during the first build and after running <code>build clean</code>, as then Shake has no information about the predicted execution time for each rule. To rebuild from scratch without running clean (because you really want to see the progress bar!) you can use the argument <code>--always-make</code>, which assumes all rules need rerunning.</p>
<span class="target" id="lint"></span><span class="target" id="lint"></span><h4><a href="#lint" class="anchor">Lint</a></h4>
<p>Shake features a built in &quot;lint&quot; feature to check the build system is well formed. To run use <code>build --lint</code>. You are likely to catch more lint violations if you first <code>build clean</code>. Sadly, lint does <i>not</i> catch missing dependencies. However, it does catch:</p>
<ul><li>Changing the current directory, typically with <code>setCurrentDirectory</code>. You should never change the current directory within the build system as multiple rules running at the same time share the current directory. You can still run <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> calls in different directories using the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:Cwd">Cwd</a></code> argument.</li>
<li>Outputs that change after Shake has built them. The usual cause of this error is if the rule for <code>foo</code> also writes to the file <code>bar</code>, despite <code>bar</code> having a different rule producing it.</li>
</ul>
<p>There is a performance penalty for building with <code>--lint</code>, but it is typically small. For more details see <a href="./lint">this page on all the Lint options</a>.</p>
<span class="target" id="profiling"></span><span class="target" id="profiling-and-optimisation"></span><h4><a href="#profiling-and-optimisation" class="anchor">Profiling and optimisation</a></h4>
<p>Shake features an advanced profiling feature. To build with profiling run <code>build --report</code>, which will generate an interactive HTML profile named <code>report.html</code>. This report lets you examine what happened in that run, what takes most time to run, what rules depend on what etc. For a full explanation of how to profile and optimise a build system, including getting accurate timings and using Haskell profiling, see <a href="./profiling">the profiling and optimisation page</a>.</p>
<span class="target" id="tracing-and-debugging"></span><h4><a href="#tracing-and-debugging" class="anchor">Tracing and debugging</a></h4>
<p>To debug a build system there are a variety of techniques that can be used:</p>
<ul><li>Run with lint checking enabled (<code>--lint</code>), which may spot and describe the problem for you.</li>
<li>Run in single-threaded mode (<code>-j1</code>) to make any output clearer by not interleaving commands.</li>
<li>By default a Shake build system prints out a message every time it runs a command. Use verbose mode (<code>--verbose</code>) to print more information to the screen, such as which rule is being run. Additional <code>--verbose</code> flags increase the verbosity. Three verbosity flags produce output intended for someone debugging the Shake library itself, rather than a build system based on it.</li>
<li>To raise a build error call <code>error <span class="str">&quot;error message&quot;</span></code>. Shake will abort, showing the error message.</li>
<li>To output additional information use <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:putNormal">putNormal</a> <span class="str">&quot;output message&quot;</span></code>. This message will be printed to the console when it is reached.</li>
<li>To show additional information with either <code>error</code> or <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:putNormal">putNormal</a></code>, use <code>error $ <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake-Classes.html#v:show">show</a> <span class="sym">(</span><span class="str">&quot;message&quot;</span>, myVariable<span class="sym">)</span></code>. This allows you to show any local variables.</li>
</ul>
<span class="target" id="extensions"></span><h2><a href="#extensions" class="anchor">Extensions</a></h2>
<p>This section details a number of build system features that are useful in some build systems, but not the initial example, and not most average build systems.</p>
<span class="target" id="advanced-cmd-usage"></span><h4><a href="#advanced-cmd-usage" class="anchor">Advanced <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd">cmd</a></code> usage</a></h4>
<p>The <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> has a related function <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd">cmd</a></code> that can also obtain the stdout and stderr streams, along with the  exit code. As an example:</p>
<pre><span class="sym">(</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Exit">Exit</a> code, <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Stdout">Stdout</a> out, <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Stderr">Stderr</a> err<span class="sym">)</span> <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd">cmd</a> <span class="str">&quot;gcc --version&quot;</span></code></pre>
<p>Now the variable <code>code</code> is bound to the exit code, while <code>out</code> and <code>err</code> are bound to the stdout and stderr streams. If <code>ExitCode</code> is not requested then any non-zero return value will raise an error.</p>
<p>Both <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a></code> and <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd">cmd</a></code> also take additional parameters to control how the command is run. As an example:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:Shell">Shell</a> <span class="sym">(</span><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:Cwd">Cwd</a> <span class="str">&quot;temp&quot;</span><span class="sym">)</span> <span class="str">&quot;pwd&quot;</span></code></pre>
<p>This runs the <code>pwd</code> command through the system shell, after first changing to the <code>temp</code> directory.</p>
<span class="target" id="dependencies-on-environment-variables"></span><h4><a href="#dependencies-on-environment-variables" class="anchor">Dependencies on environment variables</a></h4>
<p>You can use tracked dependencies on environment variables using the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getEnv">getEnv</a></code> function. As an example:</p>
<pre>link <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:getEnv">getEnv</a> <span class="str">&quot;C_LINK_FLAGS&quot;</span>
<span class="key">let</span> linkFlags <span class="sym">=</span> fromMaybe <span class="str">&quot;&quot;</span> link
<a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;gcc -o&quot;</span> <span class="sym">[</span>output<span class="sym">]</span> inputs linkFlags</code></pre>
<p>This example gets the <code>$C_LINK_FLAGS</code> environment variable (which is <code>Maybe String</code>, namely a <code>String</code> that might be missing), then using <code>fromMaybe</code> defines a local variable <code>linkFlags</code> that is the empty string when <code>$C_LINK_FLAGS</code> is not set. It then passes these flags to <code>gcc</code>.</p>
<p>If the <code>$C_LINK_FLAGS</code> environment variable changes then this rule will rebuild.</p>
<span class="target" id="dependencies-on-extra-information"></span><h4><a href="#dependencies-on-extra-information" class="anchor">Dependencies on extra information</a></h4>
<p>Using Shake we can depend on arbitrary extra information, such as the version of <code>gcc</code>, allowing us to automatically rebuild all C files when a different compiler is placed on the path. To track the version, we can define a rule for the file <code>gcc.version</code> which changes only when <code>gcc --version</code> changes:</p>
<pre><span class="str">&quot;gcc.version&quot;</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> <span class="sym">\</span>out <span class="sym">-&gt;</span> <span class="key">do</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:alwaysRerun">alwaysRerun</a>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:Stdout">Stdout</a> stdout <span class="sym">&lt;-</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd">cmd</a> <span class="str">&quot;gcc --version&quot;</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:writeFileChanged">writeFileChanged</a> out stdout</code></pre>
<p>This rule has the action <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:alwaysRerun">alwaysRerun</a></code> meaning it will be run in every execution that requires it, so the <code>gcc --version</code> is always checked. This rule defines no dependencies (no <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a></code> actions), so if it lacked <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:alwaysRerun">alwaysRerun</a></code>, this rule would only be run when <code>gcc.version</code> was missing. The function then runs <code>gcc --version</code> storing the output in <code>stdout</code>. Finally, it calls <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:writeFileChanged">writeFileChanged</a></code> which writes <code>stdout</code> to <code>out</code>, but only if the contents have changed. The use of <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:writeFileChanged">writeFileChanged</a></code> is important otherwise <code>gcc.version</code> would change in every run. To use this rule, we <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:need">need</a> <span class="sym">[</span><span class="str">&quot;gcc.version&quot;</span><span class="sym">]</span></code> in every rule that calls <code>gcc</code>.</p>
<p>Shake also contains a feature called &quot;oracles&quot;, which lets you do the same thing without the use of a file, which is sometimes more convenient. Interested readers should look at the function documentation list for <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:addOracle">addOracle</a></code>.</p>
<span class="target" id="resources"></span><h4><a href="#resources" class="anchor">Resources</a></h4>
<p>Resources allow us to limit the number of simultaneous operations more precisely than just the number of simultaneous jobs (the <code>-j</code> flag). For example, calls to compilers are usually CPU bound but calls to linkers are usually disk bound. Running 8 linkers will often cause an 8 CPU system to grid to a halt. We can limit ourselves to 4 linkers with:</p>
<pre>disk &lt;- newResource &quot;Disk&quot; 4
want [show i &lt;.&gt; &quot;exe&quot; | i &lt;- [1..100]]
&quot;*.exe&quot; %&gt; \out -&gt; do
    withResource disk 1 $ do
        cmd_ &quot;ld -o&quot; [out] ...
&quot;*.o&quot; %&gt; \out -&gt; do
    cmd_ &quot;cl -o&quot; [out] ...</code></pre>
<p>Assuming <code>-j8</code>, this allows up to 8 compilers, but only a maximum of 4 linkers.</p>
<span class="target" id="multiple-outputs"></span><h4><a href="#multiple-outputs" class="anchor">Multiple outputs</a></h4>
<p>Some tools, for example <a href="https://www.gnu.org/software/bison/">bison</a>, can generate multiple outputs from one execution. We can track these in Shake using the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-38--37--62-">&amp;%&gt;</a></code> operator to define rules:</p>
<pre><span class="sym">[</span><span class="str">&quot;//*.bison.h&quot;</span>,<span class="str">&quot;//*.bison.c&quot;</span><span class="sym">]</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-38--37--62-">&amp;%&gt;</a> <span class="sym">\</span><span class="sym">[</span>outh, outc<span class="sym">]</span> <span class="sym">-&gt;</span> <span class="key">do</span>
    <span class="key">let</span> src <span class="sym">=</span> outc -&lt;.&gt; <span class="str">&quot;y&quot;</span>
    <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:cmd_">cmd_</a> <span class="str">&quot;bison -d -o&quot;</span> <span class="sym">[</span>outc<span class="sym">]</span> <span class="sym">[</span>src<span class="sym">]</span></code></pre>
<p>Now we define a list of patterns that are matched, and get a list of output files. If any output file is required, then all output files will be built, with proper dependencies.</p>
<span class="target" id="changing-build-rules"></span><h4><a href="#changing-build-rules" class="anchor">Changing build rules</a></h4>
<p>Shake build systems are set up to rebuild files when the dependencies change, but mostly assume that the build rules themselves do not change (including both the code and the shell commands contained within). To minimise the impact of build rule changes there are three approaches:</p>
<p><i>Use configuration files:</i> Most build information, such as which files a C file includes, can be computed from source files. Where such information is not available, such as which C files should be linked together to form an executable, use configuration files to provide the information. The rule for linking can use these configuration files, which can be properly tracked. Moving any regularly changing configuration into separate files will significantly reduce the number of build system changes.</p>
<p><i>Depend on the build source:</i> One approach is to depend on the build system source in each of the rules, then if <i>any</i> rules change, <i>everything</i> will rebuild. While this option is safe, it may cause a significant number of redundant rebuilds. As a restricted version of this technique, for a generated file you can include a dependency on the generator source and use <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:writeFileChanged">writeFileChanged</a></code>. If the generator changes it will rerun, but typically only a few generated files will change, so little is rebuilt.</p>
<p><i>Use a version stamp:</i> There is a field named <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:shakeVersion">shakeVersion</a></code> in the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#t:ShakeOptions">ShakeOptions</a></code> record. If the build system changes in a significant and incompatible way, you can change this field to force a full rebuild. If you want all rules to depend on all rules, you can put a hash of the build system source in the version field, as <a href="https://stackoverflow.com/questions/18532552/shake-how-to-reliably-automatically-force-rebuild-when-my-rules-change-becomi/18532553#18532553">described here</a>.</p>
<span class="target" id="the-haskell-zone"></span><h2><a href="#the-haskell-zone" class="anchor">The Haskell Zone</a></h2>
<p>From now on, this manual assumes some moderate knowledge of Haskell. Most of the things in this section are either impossible to do with other build systems or can be faked by shell script. None of the Haskell is particularly advanced.</p>
<span class="target" id="haskell-expressions"></span><h4><a href="#haskell-expressions" class="anchor">Haskell Expressions</a></h4>
<p>You can use any Haskell function at any point. For example, to only link files without numbers in them, we can <code>import Data.Char</code> and then write:</p>
<pre><span class="key">let</span> os <span class="sym">=</span> <span class="sym">[</span><span class="str">&quot;_build&quot;</span> &lt;/&gt; c -&lt;.&gt; <span class="str">&quot;o&quot;</span> <span class="sym">|</span> c <span class="sym">&lt;-</span> inputs, not $ any isDigit c<span class="sym">]</span></code></pre>
<p>For defining non-overlapping rules it is sometimes useful to use a more advanced predicate. For example, to define a rule that only builds results which have a numeric extension, we can use the <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-63--62-">?&gt;</a></code> rule definition function:</p>
<pre>(\x -&gt; all isDigit $ drop 1 $ takeExtension x) ?&gt; \out -&gt; do
    ...</code></pre>
<p>We first get the extension with <code>takeExtension</code>, then use <code>drop 1</code> to remove the leading <code>.</code> that <code>takeExtension</code> includes, then test that all the characters are numeric.</p>
<p>The standard <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a></code> operator is actually defined as:</p>
<pre>pattern <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-37--62-">%&gt;</a> actions <span class="sym">=</span> <span class="sym">(</span>pattern <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-63--61--61-">?==</a><span class="sym">)</span> <a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-63--62-">?&gt;</a> actions</code></pre>
<p>Where <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:-63--61--61-">?==</a></code> is a function for matching file patterns.</p>
<span class="target" id="haskell-actions"></span><h4><a href="#haskell-actions" class="anchor">Haskell Actions</a></h4>
<p>You can run any Haskell <code>IO</code> action by using <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:liftIO">liftIO</a></code>. As an example:</p>
<pre><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:liftIO">liftIO</a> $ launchMissiles True</code></pre>
<p>Most common IO operations to run as actions are already wrapped and available in the Shake library, including <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:readFile'">readFile'</a></code>, <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:writeFile'">writeFile'</a></code> and <code><a href="https://hackage.haskell.org/package/shake/docs/Development-Shake.html#v:copyFile'">copyFile'</a></code>. Other useful functions can be found in <code>System.Directory</code>.</p>
</div><p id="footer">
    Questions? Feedback?
    <a href="https://groups.google.com/forum/?fromgroups#!forum/shake-build-system">Email us</a>.
    Collaborate through <a href="https://github.com/ndmitchell/shake">GitHub</a>.
    Ask at <a href="https://stackoverflow.com/questions/tagged/shake-build-system">StackOverflow</a>.
</p>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-286191-4', 'auto');
ga('send', 'pageview');
</script>

</body>
</html>
